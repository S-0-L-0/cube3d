ğŸ¯ FLUSSO COMPLETO DATI CUB3D
ğŸ“‹ STEP-BY-STEP EXECUTION FLOW
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚     MAIN()      â”‚ <- Punto di ingresso
â”‚                 â”‚
â”‚ 1. Valida args  â”‚
â”‚ 2. init_game()  â”‚ <- Azzera t_game
â”‚ 3. parse_map()  â”‚ <- ORCHESTRATORE PRINCIPALE
â”‚ 4. game_loop()  â”‚ <- Loop infinito
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚
         â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   PARSE_MAP()   â”‚ <- Coordinatore parsing + setup
â”‚                 â”‚
â”‚ A. parse_complete_file() <- RIEMPIE map + player
â”‚ B. init_mlx()           <- RIEMPIE mlx
â”‚ C. init_texture() x4    <- RIEMPIE textures[4]
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚
         â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚PARSE_COMPLETE() â”‚ <- Parsing principale file .cub
â”‚                 â”‚
â”‚ 1. Valida file  â”‚
â”‚ 2. read_lines() â”‚ <- Legge tutto in memoria
â”‚ 3. parse_elements() <- Estrae texture+colori
â”‚ 4. parse_map_grid() <- Costruisce griglia
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚
         â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚PARSE_MAP_GRID() â”‚ <- Costruzione griglia + validazione
â”‚                 â”‚
â”‚ 1. find_map_start()     <- Trova prima riga '1'/'0'
â”‚ 2. validate_no_empty()  <- No righe vuote in mappa
â”‚ 3. alloca grid[h][w]    <- Memoria per griglia
â”‚ 4. riempie griglia      <- Copia caratteri dal file
â”‚ 5. find_player()        <- Estrae posizione N/S/E/W
â”‚ 6. flood_fill()         <- VALIDAZIONE CRITICA
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚
         â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   GAME_LOOP()   â”‚ <- Loop infinito rendering + eventi
â”‚                 â”‚
â”‚ 1. render_frame() <- Disegna usando game->map.colors
â”‚ 2. mlx_hook()     <- Gestisce eventi tastiera
â”‚ 3. mlx_loop()     <- Ciclo infinito 60fps
â”‚                   â”‚
â”‚ USCITA: ESC -> free_game() -> exit()
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

ğŸ—‚ï¸ STRUTTURE DATI E LORO POPOLAMENTO
t_game (Struttura principale)
ctypedef struct s_game {
    t_map map;            // â¬…ï¸ Riempita da parse_complete_file()
    t_player player;      // â¬…ï¸ Riempita da find_and_validate_player()
    t_mlx mlx;            // â¬…ï¸ Riempita da init_mlx()
    t_texture textures[4]; // â¬…ï¸ Riempita da init_texture() x4
} t_game;
t_map (Dati mappa)
ctypedef struct s_map {
    char **grid;          // â¬…ï¸ Allocata e riempita in parse_map_grid()
    int width, height;    // â¬…ï¸ Calcolate da calculate_map_dimensions()
    char *north_texture;  // â¬…ï¸ Estratte da parse_file_elements()
    char *south_texture;  // â¬…ï¸ (parse_texture() per ogni direzione)
    char *west_texture;   //
    char *east_texture;   //
    int floor_color[3];   // â¬…ï¸ Estratti da parse_rgb_color()
    int ceiling_color[3]; //
} t_map;
t_player (Posizione e orientamento)
ctypedef struct s_player {
    double pos_x, pos_y;  // â¬…ï¸ Calcolate da find_and_validate_player()
    double dir_x, dir_y;  // â¬…ï¸ Impostate in base a direzione N/S/E/W
    double plane_x, plane_y; // â¬…ï¸ Piano camera per raycasting futuro
    char direction;       // â¬…ï¸ Carattere originale dal file (N/S/E/W)
} t_player;

ğŸ”„ CICLO VITA MEMORIA
ALLOCAZIONE (Durante parsing)

char **lines â† Array di righe file (temporaneo)
map->grid[height][width] â† Griglia 2D permanente
map->*_texture â† Path delle texture (stringhe)
mlx->mlx, win, img â† Strutture grafiche MLX
textures[4]->img â† Immagini texture caricate

UTILIZZO (Durante game loop)

map->grid â† Letta per collisioni e raycasting
map->colors â† Usati per rendering soffitto/pavimento
player->pos_* â† Aggiornati per movimento
textures â† Utilizzate per rendering pareti
mlx->addr â† Buffer pixel manipolato direttamente

DEALLOCAZIONE (free_game())
c// ORDINE CRITICO:
1. mlx_destroy_image(textures) // Libera texture GPU
2. free(map->grid[i])          // Libera ogni riga griglia
3. free(map->texture_paths)    // Libera path stringhe
4. mlx_destroy_image(mlx->img) // Libera buffer principale
5. mlx_destroy_window()        // Chiude finestra
6. free(mlx->mlx)              // Disconnette server grafico

âš¡ PUNTI CRITICI DEL FLUSSO
ğŸ” VALIDAZIONE FLOOD FILL
QUANDO: Dopo costruzione griglia, prima di avviare rendering
COSA: Partendo da posizione player, esplora ricorsivamente tutte le aree raggiungibili
PERCHÃ‰: Garantisce che player non possa mai "uscire" dalla mappa o raggiungere spazi aperti
ğŸ® GAME LOOP INFINITO
QUANDO: Dopo che tutte le strutture sono popolATE
COSA: Ciclo continuo di rendering + gestione eventi
MEMORIA: Tutte le strutture rimangono in memoria per accesso continuo
ğŸ§¹ CLEANUP ORDINATO
QUANDO: Prima di ogni exit() (normale o errore)
COSA: Liberazione memoria in ordine preciso per evitare crash
CRITICO: MLX richiede ordine specifico per deallocazione sicura











